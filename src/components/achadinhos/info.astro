<script is:inline>
document.addEventListener('DOMContentLoaded', () => {
    // --- SELETORES DO DOM ---
    const productGrid = document.getElementById("product-grid");
    const searchInput = document.getElementById("search");
    const loadMoreBtn = document.getElementById("load-more");

    // Elementos de Filtro
    const minPriceInput = document.getElementById("min-price");
    const maxPriceInput = document.getElementById("max-price");
    const applyPriceBtn = document.getElementById("btn-apply-price");
    const storeCheckboxes = document.querySelectorAll('input[name="store"]');
    const sortSelect = document.getElementById("sort-select");

    // Mobile Sidebar
    const mobileFilterBtn = document.getElementById("mobile-filter-btn");
    const sidebar = document.getElementById("filter-sidebar");
    const closeSidebar = document.querySelector(".close-sidebar");

    // --- ESTADO GLOBAL ---
    let allProducts = []; // Armazena TODOS os produtos vindos da API
    let filteredProducts = []; // Armazena os produtos após filtrar
    
    let state = {
        itemsToShow: 12, // Paginação simulada
        search: "",
        category: "melhor", // Valor padrão
        minPrice: null,
        maxPrice: null,
        stores: [],
        sort: "relevance"
    };

    // --- 1. BUSCA INICIAL (Carrega tudo da API) ---
    async function initFetch() {
        try {
            // Buscamos TUDO de uma vez (ou por categoria inicial)
            // Nota: Se a API suportar paginação, idealmente traga o máximo possível para filtrar aqui
            let url = `/api/buscap.json?cat=${state.category}`; 
            
            const response = await fetch(url);
            const result = await response.json();

            if (result.error) throw new Error(result.error);
            
            // Verifica se result.data é um array, senão tenta o próprio result
            allProducts = Array.isArray(result.data) ? result.data : result;
            
            // Aplica os filtros iniciais
            applyFilters();

        } catch (erro) {
            console.error("Erro ao carregar:", erro);
            if(productGrid) productGrid.innerHTML = `<p style='grid-column: 1/-1; text-align:center;'>Erro ao carregar ofertas.</p>`;
        }
    }

    // --- 2. LÓGICA DE FILTRAGEM (O Coração da Correção) ---
    function applyFilters() {
        // Começa com todos os produtos
        let tempProducts = [...allProducts];

        // A. Filtro de Categoria (se houver lógica no JSON para isso)
        // (Geralmente category é filtrado na API, mas se vier tudo misturado, filtre aqui)

        // B. Filtro de Busca (Texto)
        if (state.search) {
            const term = state.search.toLowerCase();
            tempProducts = tempProducts.filter(p => 
                p.title.toLowerCase().includes(term)
            );
        }

        // C. Filtro de Preço
        if (state.minPrice) {
            tempProducts = tempProducts.filter(p => parseFloat(p.price) >= parseFloat(state.minPrice));
        }
        if (state.maxPrice) {
            tempProducts = tempProducts.filter(p => parseFloat(p.price) <= parseFloat(state.maxPrice));
        }

        // D. Filtro de Lojas (Checkbox)
        if (state.stores.length > 0) {
            tempProducts = tempProducts.filter(p => {
                // Normaliza o nome da loja (Amazon -> amazon) para comparar
                const pStore = p.store ? p.store.toLowerCase().replace(/\s/g, '') : '';
                return state.stores.includes(pStore);
            });
        }

        // E. Ordenação
        if (state.sort === 'price_asc') {
            tempProducts.sort((a, b) => parseFloat(a.price) - parseFloat(b.price));
        } else if (state.sort === 'price_desc') {
            tempProducts.sort((a, b) => parseFloat(b.price) - parseFloat(a.price));
        }
        // 'relevance' mantemos a ordem original ou lógica própria

        // Salva e renderiza
        filteredProducts = tempProducts;
        state.itemsToShow = 12; // Reseta paginação ao filtrar
        renderProducts();
    }

    // --- 3. RENDERIZAÇÃO NA TELA ---
    function renderProducts() {
        if (!productGrid) return;

        productGrid.innerHTML = "";
        
        // Pega apenas a fatia baseada no "Carregar Mais"
        const visibleItems = filteredProducts.slice(0, state.itemsToShow);

        if (visibleItems.length === 0) {
            productGrid.innerHTML = `<div style='grid-column: 1/-1; text-align:center; padding: 40px; color: #666;'>Nenhum produto encontrado com esses filtros.</div>`;
            if(loadMoreBtn) loadMoreBtn.style.display = "none";
            return;
        }

        visibleItems.forEach(p => {
            // Normaliza classe da loja para CSS
            const storeClass = p.store ? `badge-${p.store.toLowerCase().replace(/\s/g, '')}` : 'badge-default';
            
            const card = document.createElement("article");
            card.className = "card";
            card.innerHTML = `
                <div class="card-img-wrapper">
                    <span class="store-badge ${storeClass}">${p.store || 'Oferta'}</span>
                    <img src="${p.img || p.image}" alt="${p.title}" loading="lazy">
                </div>
                <div class="card-info">
                    <h3>${p.title}</h3>
                    <div class="price-row">
                        <span class="card-price">R$ ${p.price}</span>
                        <a href="${p.url}" class="btn-ver" target="_blank">Ver</a>
                    </div>
                </div>
            `;
            productGrid.appendChild(card);
        });

        // Botão Carregar Mais
        if (loadMoreBtn) {
            loadMoreBtn.style.display = (filteredProducts.length > state.itemsToShow) ? "inline-block" : "none";
        }
    }

    // --- 4. EVENT LISTENERS (Interação do Usuário) ---

    // Preço
    if(applyPriceBtn) {
        applyPriceBtn.addEventListener("click", () => {
            state.minPrice = minPriceInput.value;
            state.maxPrice = maxPriceInput.value;
            applyFilters();
            // Mobile UX: fecha sidebar
            if(window.innerWidth <= 900 && sidebar) sidebar.classList.remove("active");
        });
    }

    // Lojas
    storeCheckboxes.forEach(checkbox => {
        checkbox.addEventListener("change", (e) => {
            const val = e.target.value.toLowerCase();
            if (e.target.checked) {
                state.stores.push(val);
            } else {
                state.stores = state.stores.filter(s => s !== val);
            }
            applyFilters();
        });
    });

    // Ordenação
    if(sortSelect) {
        sortSelect.addEventListener("change", (e) => {
            state.sort = e.target.value;
            applyFilters();
        });
    }

    // Busca (Com delay para não travar)
    let timer;
    if(searchInput) {
        searchInput.addEventListener("input", (e) => {
            clearTimeout(timer);
            timer = setTimeout(() => {
                state.search = e.target.value.trim();
                applyFilters();
            }, 500);
        });
    }

    // Botão Carregar Mais
    if(loadMoreBtn) {
        loadMoreBtn.addEventListener("click", () => {
            state.itemsToShow += 12;
            renderProducts();
        });
    }

    // Categorias (Pills no topo)
    document.querySelectorAll(".pill-btn[data-tab]").forEach(btn => {
        btn.addEventListener("click", (e) => {
            // Se for link <a>, deixa navegar. Se for botão JS:
            e.preventDefault(); 
            document.querySelectorAll(".pill-btn").forEach(b => b.classList.remove("active"));
            btn.classList.add("active");
            state.category = btn.dataset.tab;
            
            // Opcional: Recarregar API se mudar categoria radicalmente
            // initFetch(); 
            // OU apenas filtrar se os dados já estiverem todos aqui
            applyFilters(); 
        });
    });

    // Mobile Sidebar Toggle
    if(mobileFilterBtn) {
        mobileFilterBtn.addEventListener("click", () => {
            if(sidebar) sidebar.classList.add("active");
        });
    }
    if(closeSidebar) {
        closeSidebar.addEventListener("click", () => {
            if(sidebar) sidebar.classList.remove("active");
        });
    }

    // Inicializa
    initFetch();
});
</script>